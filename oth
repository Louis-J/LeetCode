+++++++++++++++++++++++++++++++++++++++++++++AnUniqueClass+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>

using namespace std;


#define TestSon0 0
#define TestSon1 0
#define TestSon2 0
class Father0 final{
    int i;
public:
    Father0():i(0){}

    friend ostream& operator<<(ostream &ostr,Father0 &f)
    {
        return ostr << "Father0 = " << f.i;
    }
};

class Father1{
    int i;
private:
    Father1():i(1){}
public:
    static Father1 getIns()
    {
        return Father1();
    }

    friend ostream& operator<<(ostream &ostr,Father1 &f)
    {
        return ostr << "Father1 = " << f.i;
    }
};

class Father2;
class GrandFather2{
    friend Father2;
private:
    GrandFather2(){}
};
class Father2:public virtual GrandFather2{
    int i;
public:
    Father2():i(2){}

    friend ostream& operator<<(ostream &ostr,Father2 &f)
    {
        return ostr << "Father2 = " << f.i;
    }
};

#if TestSon0
class Son0:public Father0{
public:
    void Run()
    {
        cout << "Son0 is Running!";
    }
};
#endif

#if TestSon1
class Son1:public Father1{
public:
    void Run()
    {
        cout << "Son1 is Running!";
    }
};
#endif


#if TestSon2
class Son2:public Father2{
public:
    void Run()
    {
        cout << "Son2 is Running!" << endl;
    }
};
#endif

int main()
{
    Father0 f0;
    Father1 f1 = Father1::getIns();
    Father2 f2;
    cout << f0 << endl;
    cout << f1 << endl;
    cout << f2 << endl;

    #if TestSon0
    Son0 s0;
    s0.Run();
    #endif
    #if TestSon1
    Son1 s1;
    s1.Run();
    #endif
    #if TestSon2
    Son2 s2;
    s2.Run();
    #endif
    return 0;
}
---------------------------------------------AnUniqueClass---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++Formaters+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <boost/format.hpp>
#include <boost/timer.hpp>
#include <boost/progress.hpp>

using namespace std;


char i8 = -100;
short i16 = -20000;
long i32 = -3000000;
long long i64 = -400000000;

unsigned char u8 = 100;
unsigned short u16 = 20000;
unsigned long u32 = 3000000;
unsigned long long u64 = 400000000;

char strc[] = "hahahahahahahaha";
string strp = "hohohohohohohoho";

float f = 1.234567f;
double d = 1.2345678912345;

void cFormat()
{
    cout << "全数据输出";
    {
        int i=1000000;
        boost::progress_timer timer;
        boost::progress_display pd(i);
        char *str = new char[1000];
        for(; i--; ++pd){
            sprintf(str, "%d%d%ld%lld%d%d%ld%lld %f%lf %s%s", i8, i16, i32, i64, u8, u16, u32, u64, f, d, strc, strp.c_str());
        }
        //cout << str << endl;
        delete[] str;
    }
    cout << "单数据多种格式化输出";
    {
        int i=1000000;
        boost::progress_timer timer;
        boost::progress_display pd(i);
        char *str = new char[1000];
        for(; i--; ++pd){
            sprintf(str, "%d%d%ld%lld%d%d%ld%lld %f%lf %s%s", i8, i16, i32, i64, u8, u16, u32, u64, f, d, strc, strp.c_str());
        }
        //cout << str << endl;
        delete[] str;
    }
    return;
}
int main()
{
    cFormat();
    cout << boost::format("%1% haha %1%\n")%"hoho";
    cout << "Hello world!" << endl;
    return 0;
}
---------------------------------------------Formaters---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++rangev3+++++++++++++++++++++++++++++++++++++++++++++
C++17 numeric interval
(ranged-based for loop friendly)

    Basic range:

      for(auto x : range(0,10) )
      { /* ... */ }  //  0,1,2,3,4,5,6,7,8,9

    Custom step:

     for(auto x : range(-10, 10, step{2}) )
     { /* ... */ }  //  -10,-8,-6,-4,-2,0,2,4,6,8

    Custom constexpr step:

     for(auto x : range(0, 20, int_step<3>{}) )
     { /* ... */ }  //  0,3,6,9,12,15,18

    Custom lambda step:

     for(auto x : range(1, 20, [](auto& v){ v = 2*v; }) )
     { /* ... */ }  //  1,2,4,8,16

    Other types:

     for(auto x : range(0.5f, 5.3f, step{0.7f}) )
     { /* ... */ }  // 0.5,1.2,1.9,2.6,3.3,4.0,4.7

    Custom comparison - inclusive right border:

     for(auto x : range(5, 10, step{1}, std::less_equal{}) )
     { /* ... */ }  //  5,6,7,8,9,10

    Custom comparison - reversed traversal:

     for(auto x : range(10, 0, step{-1}, std::greater{}) )
     { /* ... */ }  //  10,9,8,7,6,5,4,3,2,1

The last example can be somewhat improved syntactically (default to std::greater depending on step).---------------------------------------------rangev3---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++switch_string+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>

using namespace std;
namespace const_expr_hash64{
    typedef long long hash64;
    constexpr hash64 prime = 0x100000001B3ull;
    constexpr hash64 basis = 0xCBF29CE484222325ull;
    constexpr hash64 hash_static(char const* str)
    {
        return (*str) ? (*(str + 1)) ? (((*str) * prime + basis) ^ hash_static(str + 1)) : ((*str) * prime + basis) : 0;
    }
    constexpr hash64 operator "" _hash(char const* p, size_t)
    {
        return hash_static(p);
    }
};
using namespace const_expr_hash64;

int main()
{
    if(string s; cin >> s){
        switch(hash<string>{}(s)){
        case "haha"_hash:
            cout << "haha\n";
            break;
        case "hoho"_hash:
            cout << "hoho\n";
            break;
        case "hehe"_hash:
            cout << "hehe\n";
            break;
        }
    }
    return 0;
}
---------------------------------------------switch_string---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++unique_ptr+++++++++++++++++++++++++++++++++++++++++++++
#include<iostream>
#include<vector>
#include<algorithm>
#include<sstream>
#include<string>
#include<memory>
#include<assert.h>

using namespace std;

class Test {
private:
    string str;
public:
    Test(string str):str(str){}
    Test(Test &t):str(t.str){}
    ~Test(){
        cout << str << " destructor\n";
    }
    void print() {
        cout << str << '\n';
    }
};

int main() {
    unique_ptr<Test> t1(new Test("t1"));
    unique_ptr<Test> t2(move(t1));
    //unique_ptr<Test> t4(t1);
    unique_ptr<Test> t5(new Test(*t1));
    if (int i; cin >> i) {
        switch(i){
            case 0:{
                unique_ptr<Test> t3(move(t1));
                t3->print();
                break;
            }
            case 1:{
                unique_ptr<Test> t3(move(t2));
                t3->print();
                break;
            }
            case 2:
            default:{
                t2->print();
                break;
            }
        }
    }
    t2->print();
    return 0;
}
---------------------------------------------unique_ptr---------------------------------------------
