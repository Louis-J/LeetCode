}

string integerVectorToString(vector<int> list, int length = -1) {
    if (length == -1) {
        length = list.size();
    }

    if (length == 0) {
        return "[]";
    }

    string result;
    for(int index = 0; index < length; index++) {
        int number = list[index];
        result += to_string(number) + ", ";
    }
    return "[" + result.substr(0, result.length() - 2) + "]";
}

int main() {
    string line;
    while (getline(cin, line)) {
        int n = stringToInteger(line);

        vector<int> ret = Solution().grayCode(n);

        string out = integerVectorToString(ret);
        cout << out << endl;
    }
    return 0;
}
---------------------------------------------0089---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0091+++++++++++++++++++++++++++++++++++++++++++++
#include<iostream>
#include<vector>
#include<algorithm>
#include<sstream>
#include<string>
#include<memory>
#include <boost/progress.hpp>
#include<assert.h>
#include <range/v3/all.hpp>

using namespace std;
using namespace ranges;

class Solution {
private:
    class Fib{
    private:
        vector<int> fib;
    public:
        Fib():fib(2, 1){}
        int operator()(int n){
            if(n >= fib.size()){
                for(int i = fib.size(); i <= n; i++){
                    fib.emplace_back(fib[i - 1] + fib[i - 2]);
                }
            }
            return fib[n];
        }
    };
    static Fib f;
public:
    //O(n),分类累乘法
    int numDecodings0(string s) {
        int rlt = 1;
        for(int i = -1, j = 0;; j++){
            if(j >= s.size()){
                rlt *= f(j - i - 1);
                break;
            }else if(s[j] == '0'){
                if(j-1 == i || s[j-1] >= '3'){
                    return 0;
                }else{
                    rlt *= f(j - i - 2);
                    i = j;
                }
            }else if(s[j] == '0' || (s[j] >= '7' && (j-1 > i && s[j-1] == '2'))){
                rlt *= f(j - i - 1);
                i = j;
            }else if(s[j] >= '3'){
                rlt *= f(j - i);
                i = j;
            }
        }
        return rlt;
    }
    //O(n),分类累加法
    int numDecodings1(string s) {
        if(s.size() == 0 || s[0] == '0'){
            return 0;
        }
        int sum = 1, sum_1 = 1, sum_2 = 1;
        for(int i = 1; i < s.size(); i++){
            int now = s[i-1]*10 + s[i] - 11*'0';
            if(now == 10 || now == 20){
                sum = sum_2;
            }else if(s[i] == '0'){
                return 0;
            }else if(now > 26 || now < 10){
                sum = sum_1;
            }else{
                sum = sum_1 + sum_2;
            }
            sum_2 = sum_1;
            sum_1 = sum;
        }
        return sum;
    }
};
Solution::Fib Solution::f;

string stringToString(string input) {
    assert(input.length() >= 2);
    string result;
    for (int i = 1; i < input.length() -1; i++) {
        char currentChar = input[i];
        if (input[i] == '\\') {
            char nextChar = input[i+1];
            switch (nextChar) {
                case '\"': result.push_back('\"'); break;
                case '/' : result.push_back('/'); break;
                case '\\': result.push_back('\\'); break;
                case 'b' : result.push_back('\b'); break;
                case 'f' : result.push_back('\f'); break;
                case 'r' : result.push_back('\r'); break;
                case 'n' : result.push_back('\n'); break;
                case 't' : result.push_back('\t'); break;
                default: break;
            }
            i++;
        } else {
          result.push_back(currentChar);
        }
    }
    return result;
}

int main() {
    string line;
    while (getline(cin, line)) {
        string s = stringToString(line);
        const int nums = 10000;
        {
            boost::progress_timer timer;
            for(int i = 0; i < nums; i++){
                int ret = Solution().numDecodings0(s);
            }
            cout << "0:";
        }

        {
            boost::progress_timer timer;
            for(int i = 0; i < nums; i++){
                int ret = Solution().numDecodings1(s);
            }
            cout << "1:";
        }
    }
    return 0;
}
---------------------------------------------0091---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0093+++++++++++++++++++++++++++++++++++++++++++++
#include<iostream>
#include<vector>
#include<algorithm>
#include<sstream>
#include<string>
#include<memory>
//#include <boost/progress.hpp>
#include<assert.h>
//#include <range/v3/all.hpp>

using namespace std;
//using namespace ranges;

class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        vector<string> rlt;
        for(int i = 1; i < s.size() && i <= 3 &&
            !(i >= 2 && s[0] == '0') &&
            !(i == 3 && s[0]*100+s[1]*10+s[2] - '0'*111> 255); i++){
            for(int j = i+1; j < s.size() && j-i <= 3 &&
                !(j-i >= 2 && s[i] == '0') &&
                !(j-i == 3 && s[i]*100+s[i+1]*10+s[i+2] - '0'*111> 255); j++){
                for(int k = j+1; k < s.size() && k-j <= 3 &&
                    !(k-j >= 2 && s[j] == '0') &&
                    !(k-j == 3 && s[j]*100+s[j+1]*10+s[j+2] - '0'*111> 255); k++){
                    if(int l = s.size()-k; l <= 3 && l <= 3 &&
                        !(l >= 2 && s[k] == '0') &&
                        !(l == 3 && s[k]*100+s[k+1]*10+s[k+2] - '0'*111> 255)){
                        rlt.emplace_back(s.substr(0, i) + "." +
                                            s.substr(i, j-i) + "." +
                                            s.substr(j, k-j) + "." +
                                            s.substr(k, s.size()-k));
                    }
                }
            }
        }
        return rlt;
    }
};

int main() {
    string line;
    while (cin >> line) {
        auto ret = Solution().restoreIpAddresses(line);
        for(auto r : ret){
            cout << r << endl;
        }
    }
    return 0;
}
---------------------------------------------0093---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0113+++++++++++++++++++++++++++++++++++++++++++++
#include<iostream>
#include<vector>
#include<algorithm>
#include<sstream>
#include<string>
#include<memory>
//#include <boost/progress.hpp>
#include<assert.h>
//#include <range/v3/all.hpp>

#include<cstdio>
#include <cstdarg>

using namespace std;
//using namespace ranges;


struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x=0) : val(x), left(NULL), right(NULL) {}
};


class Solution {
public:
    //倒序输出,因为有数组移动所以速度较慢
    vector<vector<int>> pathSum0(TreeNode* root, int sum) {
        //cout << root->val << endl;
        if(root == nullptr){
            return vector<vector<int>>();
        }else if(root->left != nullptr){
            if(root->right == nullptr){
                vector<vector<int>> &&l(pathSum(root->left, sum - root->val));
                for(auto &i : l){
                    i.emplace(i.begin(), root->val);
                }
                return l;
            }else{
                vector<vector<int>> &&l(pathSum(root->left, sum - root->val));
                vector<vector<int>> &&r(pathSum(root->right, sum - root->val));
                l.insert(l.end(), r.begin(), r.end());
                for(auto &i : l){
                    i.emplace(i.begin(), root->val);
                }
                return l;
            }
        }else if(root->right != nullptr){
            vector<vector<int>> &&r(pathSum(root->right, sum - root->val));
            for(auto &i : r){
                i.emplace(i.begin(), root->val);
            }
            return r;
        }else if(sum == root->val){
            return vector<vector<int>>{{sum}};
        }else{
            return vector<vector<int>>();
        }
    }

    //简单优化代码量,性能有可能降低
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        //cout << root->val << endl;
        if(root == nullptr){
            return vector<vector<int>>();
        }else if(sum == root->val && root->left == nullptr && root->right == nullptr){
            return vector<vector<int>>{{sum}};
        }else{
            vector<vector<int>> &&l(pathSum(root->left, sum - root->val));
            vector<vector<int>> &&r(pathSum(root->right, sum - root->val));
            l.insert(l.end(), r.begin(), r.end());
            for(auto &i : l){
                i.emplace(i.begin(), root->val);
            }
            return l;
        }
    }

    //改用list存储,增加性能
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        if(root == nullptr){
            return vector<vector<int>>();
        }else if(sum == root->val && root->left == nullptr && root->right == nullptr){
            return vector<vector<int>>{{sum}};
        }else{
            vector<vector<int>> &&l(pathSum(root->left, sum - root->val));
            vector<vector<int>> &&r(pathSum(root->right, sum - root->val));
            l.insert(l.end(), r.begin(), r.end());
            for(auto &i : l){
                i.emplace(i.begin(), root->val);
            }
            return l;
        }
    }
};


TreeNode *TreeCreate(int count, ...)
{
    va_list argptr;
    va_start(argptr, count);

    TreeNode **treeArr = new TreeNode*[count];
    for (int i = 0; i < count; i++)
    {
        int num = va_arg(argptr, int);
        if (INT_MAX == num)
            treeArr[i] = NULL;
        else
            treeArr[i] = new TreeNode(num);
    }

    int curr = 1;
    for (int i = 0; i<count; i++)
    {
        if( !treeArr[i] )
            continue;

        if( curr < count )
            treeArr[i]->left = treeArr[curr++];
        if (curr < count)
            treeArr[i]->right = treeArr[curr++];
    }

    va_end(argptr);
    return treeArr[0];
}


void IntVector2DPrint(const vector<vector<int>> &vec)
{
    printf("[\n");
    for (size_t i = 0; i < vec.size(); i++)
    {
        printf("[ ");
        for (size_t j = 0; j < vec[i].size(); j++)
            printf("%d, ", vec[i][j]);
        printf(" ]\n");
    }
    printf("]\n");
}
int main() {
    TreeNode *tree = TreeCreate(12,5,4,8,11,INT_MAX,13,4,7,2,INT_MAX,INT_MAX,5,1);
    IntVector2DPrint(Solution().pathSum(tree, 22));
    return 0;
}
---------------------------------------------0113---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0127+++++++++++++++++++++++++++++++++++++++++++++
#include<iostream>
#include<vector>
#include<list>
#include<algorithm>
#include<sstream>
#include<string>
#include<memory>
#include<map>
//#include <boost/progress.hpp>
#include<assert.h>
//#include <range/v3/all.hpp>
#include<cstdarg>

using namespace std;
//using namespace ranges;

class Solution {
public:
    //类djistra，628ms，性能有点低
    int ladderLength0(std::string beginWord, string endWord, vector<string>& wordList) {
        auto ifnext = [](string& a, string& b){
            for(int i = 0, sum = 0; i < a.size(); i++){
                if(a[i] != b[i] && ++sum >= 2){
                    return false;
                }
            }
            return true;
        };

        list<string> words;
        bool has = false;
        for(auto& s : wordList){
            if(!has && s == endWord){
                has = true;
            }else{
                words.emplace_back(s);
            }
        }
        if(!has){
            return 0;
        }
        multimap<int, string> rlt;
        rlt.emplace(1, beginWord);
        auto instep = [&](int step, auto& w){
            for(auto i = rlt.lower_bound(step); i != rlt.upper_bound(step); i++){
                if(ifnext(*w, i->second)){
                    rlt.emplace(step+1, *w);
                    w = words.erase(w);
                    return true;
                }
            }
            return false;
        };

        for(int i = 1; rlt.find(i) != rlt.end(); i++){
            for(auto j = rlt.lower_bound(i); j != rlt.upper_bound(i); j++){
                if(ifnext(endWord, j->second)){
                    return i+1;
                }
            }
            for(auto w = words.begin(); w != words.end();){
                if(!instep(i, w)){
                    w++;
                }
            }
        }
        return 0;
    }
    //试试最简单的递归实现
    int ladderLength(std::string beginWord, string endWord, vector<string>& wordList) {
        auto ifnext = [](string& a, string& b){
            for(int i = 0, sum = 0; i < a.size(); i++){
                if(a[i] != b[i] && ++sum >= 2){
                    return false;
                }
            }
            return true;
        };

        function recursion;
        recursion = [&](){
            
        };
        
        return 0;
    }
    //神级解答，没看懂
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> hashset(wordList.begin(), wordList.end());
        if (!hashset.count(endWord)) return 0;
        
        unordered_set<string> stset{ beginWord };
        unordered_set<string> edset{ endWord };
        for (int step = 1; !stset.empty() && !edset.empty(); ++step) {
            unordered_set<string> tmp;
            if (stset.size() > edset.size())
                swap(stset, edset);
            for (auto w : stset) {
                for (int i = 0; i<beginWord.size(); i++) {
                    string word = w;
                    for (int c = 'a'; c <= 'z'; c++) {
                        if (c == word[i])
                            continue;
                        else
                            word[i] = c;

                        if (edset.count(word))
                            return step + 1;
                        if (hashset.count(word)) {
                            tmp.insert(word);
                            hashset.erase(word);
                        }
                    }
                }
            }
            swap(tmp, stset);
        }
        return 0;
    }
};

 
vector<string> StringVectorCreate(int count, ...)
{
    vector<string> result;
    va_list argptr;
    va_start(argptr, count);
 
    for (int i = 0; i < count; i++)
    {
        char *str = va_arg(argptr, char*);
        result.push_back(str);
    }
    va_end(argptr);
