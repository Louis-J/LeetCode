
    for(int i = 0, j = 0;
        i != NC && j != NP
        && coupon[i] < 0 && bonus[j] < 0; i ++, j ++){
        sum += coupon[i] * bonus[j];
    }

    for(int i = NC, j = NP;
        i != 0 && j != 0
        && coupon[i-1] > 0 && bonus[j-1] > 0; i --, j --){
        sum += coupon[i-1] * bonus[j-1];
    }
    cout << sum;
    return 0;
}
#else
int main()
{
    int NC, NP;
    vector<long long> coupon, bonus;
    cin >> NC;
    coupon.resize(NC);
    for(int i = 0; i < NC; i ++){
        cin >> coupon[i];
    }
    cin >> NP;
    bonus.resize(NP);
    for(int i = 0; i < NP; i ++){
        cin >> bonus[i];
    }
    sort(coupon.begin(), coupon.end());
    sort(bonus.begin(), bonus.end());

    long long sum = 0;

    for(vector<long long>::iterator i = coupon.begin(), j = bonus.begin();
        i != coupon.end() && j != bonus.end()
        && *i < 0 && *j < 0; i ++, j ++){
        sum += *i * *j;
    }

    for(vector<long long>::reverse_iterator i = coupon.rbegin(), j = bonus.rbegin();
        i != coupon.rend() && j != bonus.rend()
        && *i > 0 && *j > 0; i ++, j ++){
        sum += *i * *j;
    }
    cout << sum;
    return 0;
}
#endif
//题目有错，应为nt就可，但出现溢出数据

---------------------------------------------pat4024---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++Pat4093+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <map>

using namespace std;

template<typename T1, typename T2, typename T3>
//bool operator>(const pair<const int, int>& a, const pair<int, int>& b)
bool operator>(const pair<T1, T2>& a, const pair<T3, T2>& b)
{
    return a.second > b.second;
}

ostream& operator<<(ostream& ostr, pair<int, int>& p)
{
    return ostr << p.first;
}

int main()
{
    int M, N;
    map<int, int> colors;
    cin >> M >> N;

    int color;
    for(int i = 0; i < M * N; i ++){
        cin >> color;
        colors[color] ++;
    }
    pair<int, int> dominant = make_pair(0, -1);
    for(map<int, int>::iterator i = colors.begin(); i != colors.end(); i ++){
        if(*i > dominant){
            dominant = *i;
        }
    }
    cout << dominant;
    return 0;
}

//出现问题：本题重载>时，实际30行比较类型为pair<const int, int>和pair<int, int>使用模板时需注意
---------------------------------------------Pat4093---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++Pat4311+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <vector>

using namespace std;
class fraction{
    int numerator;
    int denominator;
private:
    int getGCD(fraction &f)
    {
        int l,s;
        if(denominator>=f.denominator){
            l=denominator;
            s=f.denominator;
        }else{
            s=denominator;
            l=f.denominator;
        }
        while(l%s!=0){
            int temp=l%s;
            l=s;
            s=temp;
        }
        return s;
    }
    int getLCM(fraction &f)
    {
        int GCD=getGCD(f);
        return denominator*f.denominator/GCD;
    }
    void reduction2lowest()
    {
        if(numerator==0){
            denominator=1;
            return;
        }
        int l,s;
        if(denominator>=abs(numerator)){
            l=denominator;
            s=abs(numerator);
        }else{
            s=denominator;
            l=abs(numerator);
        }
        while(l%s!=0){
            int temp=l%s;
            l=s;
            s=temp;
        }
        numerator/=s;
        denominator/=s;
    }
    void reduction2common(int r)
    {
        numerator*=r/denominator;
        denominator=r;
    }
public:
    fraction()
    {
        char c;
        cin >> numerator >> c >> denominator;
        if(numerator==0){
            denominator=1;
        }
        else{
            reduction2lowest();
        }
    }
    fraction(const fraction &f):numerator(f.numerator),denominator(f.denominator){}

public:
    friend ostream & operator <<(ostream& ostrm, fraction f)
    {
        if(abs(f.numerator)>=f.denominator||f.numerator==0){
            ostrm<<f.numerator/f.denominator<<' ';
        }
        if(f.numerator%f.denominator!=0){
            ostrm<<f.numerator%f.denominator<<'/'<<f.denominator;
        }
        return ostrm;
    }
    fraction & operator +=(fraction f)
    {
        int LCM=getLCM(f);
        reduction2common(LCM);
        f.reduction2common(LCM);
        numerator+=f.numerator;
        reduction2lowest();
        return *this;
    }
};

int main()
{
    int N=0;
    cin >> N;
    if(N>100||N<=0)
        return -1;
    vector<fraction> inputs(N);

    fraction sum(inputs[0]);
    for(int i=1;i<N;i++){
        sum += inputs[i];
    }
    cout << sum;
    return 0;
}
---------------------------------------------Pat4311---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++Pat4312+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <math.h>
using namespace std;


string itocnstr(int n)
{
    const string fu="Fu ";
    const string wei[]={"","Shi ","Bai ","Qian ","Wan ","Shi ","Bai ","Qian ","Yi "};
    const string shu[]={"ling ","yi ","er ","san ","si ","wu ","liu ","qi ","ba ","jiu "};
    string sum;

    if(n<0){
        sum+=fu;
        n=-n;
    }
    else if(n==0){
        sum=shu[0];
        return sum;
    }

    for(int i=ceil(log10(n+1))-1,last_ling=0;i>=0;i--){
        int this_wei=n/(int)pow(10.0f,i)%10;

        if(last_ling>0&&this_wei!=0){
            if(i%4!=3||last_ling-i>3){
                sum+=shu[0];
            }
            last_ling=0;
        }

        if(this_wei!=0){
            sum+=shu[this_wei];
            sum+=wei[i];
        }
        else{ //this_wei==0
            if((last_ling==0||last_ling-i<3)&&(i==8||i==4)){
                sum+=wei[i];
            }
            if(last_ling==0){ //this_wei==0,last_ling==0
                last_ling=i;
            }
        }

    }


    return sum;
}
int main()
{
    int N=0;
    cin >> N;

    cout << itocnstr(N);
    return 0;
}
---------------------------------------------Pat4312---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++Pat4313+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <algorithm>

using namespace std;

class student{
    string name;
    string ID;
    int grade;

public:
    student()
    {
        cin >> name >> ID >> grade;
    }
    bool operator<(student& s)
    {
        return grade > s.grade;
    }
    friend ostream& operator<<(ostream& ostr, student& s)
    {
        return ostr << s.name << ' ' << s.ID << endl;
    }
    bool ifinbound(int gradel, int gradeh)
    {
        return grade <= gradeh && grade >= gradel;
    }
};
int main()
{
    int N = 0, gradel = 0, gradeh = 0;
    cin >> N;
    vector<student> input(N);
    cin >> gradel >> gradeh;

    sort(input.begin(),input.end());

    bool ifnone = true;
    for(vector<student>::iterator i=input.begin();i!=input.end();i++){
        if(i->ifinbound(gradel, gradeh)){
            cout << *i;
            ifnone = false;
        }
    }
    if(ifnone){
        cout << "NONE";
    }
    return 0;
}


---------------------------------------------Pat4313---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++Pat4314+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <algorithm>

using namespace std;

class treenode{
    treenode* l;
    treenode* r;
    int value;

public:
    treenode()
    {
        string action;
        cin >> action >> value;

        if(cin >> action && action == "Push"){
            int num;
            cin >> num;
            l = new treenode(num);
        }
        else{
            l = NULL;
        }

        if(cin >> action && action == "Push"){
            int num;
            cin >> num;
            r = new treenode(num);
        }
        else{
            r = NULL;
        }
    }
    treenode(int num):value(num)
    {
        string action;

        if(cin >> action && action == "Push"){
            int num;
            cin >> num;
            l = new treenode(num);
        }
        else{
            l = NULL;
        }

        if(cin >> action && action == "Push"){
            int num;
            cin >> num;
            r = new treenode(num);
        }
        else{
            r = NULL;
        }
    }
    friend ostream& operator<<(ostream& ostr, treenode& s)
    {
        if(s.l != NULL){
            ostr << *(s.l);
        }
        if(s.r != NULL){
            ostr << *(s.r);
        }
        return ostr << s.value << ' ';
    }
};

int main()
{
    int N;
    cin >> N;
    treenode input;
    cout << input;
    return 0;
}
//出现问题：本题有EOF问题，实际给定的输入参数少一个Pop，若不进行处理则会某个节点的子节点并不是NULL而是一个奇怪的值（怀疑是C++的异常处理导致），通过if（cin>>）可解决

---------------------------------------------Pat4314---------------------------------------------
