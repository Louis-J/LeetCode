        recursion = [&recursion, &rlt, &candidates](vector<int>&& now, unsigned index, int leave){
            int nowsize = now.size();
            now.push_back(0);
            for(;index < candidates.size() && leave > candidates[index];){
                now[nowsize] = candidates[index];
                recursion(move(now), index + 1, leave - candidates[index]);
                while(++index < candidates.size() && candidates[index] == candidates[index-1]){}
            }
            if(leave == candidates[index]){
                now[nowsize] = leave;
                rlt.push_back(now);
            }
            now.resize(nowsize);
        };
        recursion(vector<int>(), 0, target);
        return rlt;
    }
};

void trimLeftTrailingSpaces(string &input) {
    input.erase(input.begin(), find_if(input.begin(), input.end(), [](int ch) {
        return !isspace(ch);
    }));
}

void trimRightTrailingSpaces(string &input) {
    input.erase(find_if(input.rbegin(), input.rend(), [](int ch) {
        return !isspace(ch);
    }).base(), input.end());
}

vector<int> stringToIntegerVector(string input) {
    vector<int> output;
    trimLeftTrailingSpaces(input);
    trimRightTrailingSpaces(input);
    input = input.substr(1, input.length() - 2);
    stringstream ss;
    ss.str(input);
    string item;
    char delim = ',';
    while (getline(ss, item, delim)) {
        output.push_back(stoi(item));
    }
    return output;
}

void IntVector2DPrint(const vector<vector<int>> &vec)
{
    printf("[\n");
    for (size_t i = 0; i < vec.size(); i++)
    {
        printf("[ ");
        for (size_t j = 0; j < vec[i].size(); j++)
            printf("%d, ", vec[i][j]);
        printf(" ]\n");
    }
    printf("]\n");
}

int stringToInteger(string input) {
    return stoi(input);
}

int main() {
    string line;
    while (getline(cin, line)) {
        vector<int> nums = stringToIntegerVector(line);
        getline(cin, line);
        int target = stringToInteger(line);

        auto ret = Solution().combinationSum2(nums, target);

        IntVector2DPrint(ret);
    }
    return 0;
}
---------------------------------------------0040---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0043+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <algorithm>
#include <vector>
#include <sstream>
#include <functional>
#include <assert.h>

using namespace std;

class Solution {
public:
    string multiply0(string num1, string num2) {
        vector<int> sum(num1.size() + num2.size(), 0);
        for(unsigned i = 0; i < num1.size(); i++){
            for(unsigned j = 0; j < num2.size(); j++){
                sum[i + j + 1] += (num1[i] - '0') * (num2[j] - '0');
            }
        }
        for(unsigned i = sum.size() - 1; i > 0; i--){
            sum[i - 1] += sum[i] / 10;
            sum[i] = sum[i] % 10 + '0';
        }
        sum[0] += '0';
        vector<int>::iterator b;
        for(b = sum.begin(); b != sum.end() && *b == '0'; b++){}
        return b == sum.end() ? string("0") : string(b, sum.end());
    }
    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0") {
            return "0";
        }
        vector<int> sum(num1.size() + num2.size(), 0);
        for(unsigned i = 0; i < num1.size(); i++){
            for(unsigned j = 0; j < num2.size(); j++){
                sum[i + j + 1] += (num1[i] - '0') * (num2[j] - '0');
            }
        }
        for(unsigned i = sum.size() - 1; i > 0; i--){
            sum[i - 1] += sum[i] / 10;
            sum[i] = sum[i] % 10 + '0';
        }
        sum[0] += '0';
        return string(sum.begin() + (sum[0] == '0' ? 1 : 0), sum.end());
    }
};

string stringToString(string input) {
    assert(input.length() >= 2);
    string result;
    for (int i = 1; i < input.length() -1; i++) {
        char currentChar = input[i];
        if (input[i] == '\\') {
            char nextChar = input[i+1];
            switch (nextChar) {
                case '\"': result.push_back('\"'); break;
                case '/' : result.push_back('/'); break;
                case '\\': result.push_back('\\'); break;
                case 'b' : result.push_back('\b'); break;
                case 'f' : result.push_back('\f'); break;
                case 'r' : result.push_back('\r'); break;
                case 'n' : result.push_back('\n'); break;
                case 't' : result.push_back('\t'); break;
                default: break;
            }
            i++;
        } else {
          result.push_back(currentChar);
        }
    }
    return result;
}

int main() {
    string line;
    while (getline(cin, line)) {
        string num1 = stringToString(line);
        getline(cin, line);
        string num2 = stringToString(line);

        string ret = Solution().multiply(num1, num2);

        string out = (ret);
        cout << out << endl;
    }
    return 0;
}
---------------------------------------------0043---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0048+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>

using namespace std;

int main()
{
    cout << "Hello world!" << endl;
    return 0;
}
---------------------------------------------0048---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0050+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <algorithm>
#include <vector>
#include <sstream>
#include <functional>
#include <assert.h>

using namespace std;

class Solution {
public:
    double myPow0(double x, int n) {
        unsigned un = abs(n);
        x = n < 0 ? 1 / x : x;

        unsigned wei;
        unsigned powwei;
        for(wei = 1, powwei = 1; powwei <= un/2; wei++, powwei *= 2){}

        vector<bool> ifadd(wei, false);
        for(unsigned i = powwei, j = wei - 1; un != 0;j--, i/= 2){
            if(un >= i){
                un -= i;
                ifadd[j] = true;
            }
        }
        double rlt = 1;
        for(auto add : ifadd){
            if(add){
                rlt *= x;
            }
            x *= x;
        }
        return rlt;
    }
    double myPow1(double x, int n) {
        unsigned un = abs(n);
        x = n < 0 ? 1 / x : x;

        double rlt = 1;
        for(unsigned i = 1; un >= i && i != 0; i *= 2){
            if(i&un){
                rlt *= x;
            }
            x *= x;
        }
        return rlt;
    }
    double myPow(double x, int n) {
        unsigned un = abs(n);
        x = n < 0 ? 1 / x : x;

        double rlt = 1;
        for(; un > 0; un /= 2){
            if(un%2){
                rlt *= x;
            }
            x *= x;
        }
        return rlt;
    }
};

int main()
{
    double x;
    int n;
    while(cin >> x >> n){
        cout << Solution().myPow(x, n) << endl;
    }
    return 0;
}
---------------------------------------------0050---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0055+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <algorithm>
#include <vector>
#include <sstream>
#include <functional>
#include <assert.h>

using namespace std;

class Solution {
public:
    bool canJump(vector<int>& nums) {
        int maxjump = -1;
        for(int i = 0; i < nums.size(); i++){
            if(maxjump < nums[i] + i){
                maxjump = nums[i] + i;
                if(maxjump >= nums.size() - 1){
                    return true;
                }
            }
            if(i == maxjump){
                return false;
            }
        }
        return false;
    }
};

void trimLeftTrailingSpaces(string &input) {
    input.erase(input.begin(), find_if(input.begin(), input.end(), [](int ch) {
        return !isspace(ch);
    }));
}

void trimRightTrailingSpaces(string &input) {
    input.erase(find_if(input.rbegin(), input.rend(), [](int ch) {
        return !isspace(ch);
    }).base(), input.end());
}

vector<int> stringToIntegerVector(string input) {
    vector<int> output;
    trimLeftTrailingSpaces(input);
    trimRightTrailingSpaces(input);
    input = input.substr(1, input.length() - 2);
    stringstream ss;
    ss.str(input);
    string item;
    char delim = ',';
    while (getline(ss, item, delim)) {
        output.push_back(stoi(item));
    }
    return output;
}

string boolToString(bool input) {
    return input ? "True" : "False";
}

int main() {
    string line;
    while (getline(cin, line)) {
        vector<int> nums = stringToIntegerVector(line);

        bool ret = Solution().canJump(nums);

        string out = boolToString(ret);
        cout << out << endl;
    }
    return 0;
}
---------------------------------------------0055---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0068+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        vector<string> rlt;
        for(int s = 0, e = 0, sum = 0;; e++){
            if(e == words.size()){
                string str(words[s]);
                for(int i = s + 1; i < e; i++){
                    str.push_back(' ');
                    str += words[i];
                }
				str.insert(str.end(), maxWidth-str.size(), ' ');
                rlt.emplace_back(str);
				break;
            }else if(sum + words[e].size() > maxWidth){
                string str(words[s]);
                for(int i = s + 1; i < e; i++){
                    str.insert(str.end(), (maxWidth - sum + e - s + e - i - 1)/(e-s-1), ' ');
                    str += words[i];
                }
                rlt.emplace_back(str);
                s = e;
                sum = words[e].size() + 1;
            }else{
            	sum += words[e].size() + 1;
            }
        }
        return rlt;
    }
};

int main()
{
	vector<string> words{"This", "is", "an", "example", "of", "text", "justification."};
	int maxWidth = 16;
	for(auto &s : Solution().fullJustify(words, maxWidth)){
		cout << s << endl;
	}
    return 0;
}
---------------------------------------------0068---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0071+++++++++++++++++++++++++++++++++++++++++++++
#include <iostream>
#include <algorithm>
#include <vector>
#include <list>
#include <sstream>
#include <functional>
#include <assert.h>

using namespace std;

class Solution {
public:
    string simplifyPath(string path) {
        list<string> paths;
        for(int b = 0, e = path.find('/', 1); b < path.size(); b = e, e = path.find('/', e + 1)){
            paths.emplace_back(path.substr(b, e - b));
            //cout << path.substr(b, e - b) << endl;
        }
        for(list<string>::iterator i = paths.begin(); i != paths.end();){
            if(*i == "/" || *i == "/."){
                i = paths.erase(i);
            }else if(*i == "/.."){
                if(i != paths.begin()){
                    i = paths.erase(--i);
                }
                i = paths.erase(i);
            }else{
                i++;
            }
        }
        //return string(paths.begin(), paths.end());
        if(paths.size() == 0){
            return string("/");
        }
        string rlt;
        for(auto i : paths){
            rlt += i;
        }
        return rlt;
    }
};

string stringToString(string input) {
    assert(input.length() >= 2);
    string result;
    for (int i = 1; i < input.length() -1; i++) {
        char currentChar = input[i];
        if (input[i] == '\\') {
            char nextChar = input[i+1];
            switch (nextChar) {
                case '\"': result.push_back('\"'); break;
                case '/' : result.push_back('/'); break;
                case '\\': result.push_back('\\'); break;
                case 'b' : result.push_back('\b'); break;
                case 'f' : result.push_back('\f'); break;
                case 'r' : result.push_back('\r'); break;
                case 'n' : result.push_back('\n'); break;
                case 't' : result.push_back('\t'); break;
                default: break;
            }
            i++;
        } else {
          result.push_back(currentChar);
        }
    }
    return result;
}

int main() {
    string line;
    while (getline(cin, line)) {
        string path = stringToString(line);

        string ret = Solution().simplifyPath(path);

        string out = (ret);
        cout << out << endl;
    }
    return 0;
}
---------------------------------------------0071---------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++0089+++++++++++++++++++++++++++++++++++++++++++++
#include<iostream>
#include<vector>
#include<algorithm>
#include<sstream>
#include<string>
#include<memory>
#include<assert.h>
#include <range/v3/all.hpp>

using namespace std;
using namespace ranges;

class Solution {
public:
    vector<int> grayCode_rva(int n) {
        vector<int> rlt{0};
        vector<int> indexs(n+1, 1);
        for(const auto &i : view::ints(1,n+1)){
            indexs[i] = 2*indexs[i-1];
        }
        rlt.reserve(indexs[n]);
        for(const auto &i : view::ints(1,n+1)){
            for(const auto &j : rlt | view::reverse){
                rlt.emplace_back(j + indexs[i-1]);
            }
        }
        return rlt;
    }
    vector<int> grayCode(int n) {
        vector<int> rlt{0};
        vector<int> indexs(n+1, 1);
        for(int i = 1; i <= n; i++){
            indexs[i] = 2*indexs[i-1];
        }
        rlt.reserve(indexs[n]);
        for(int i = 1; i <= n; i++){
            for(auto j = rlt.rbegin(); j != rlt.rend(); j++){
                rlt.emplace_back(*j + indexs[i-1]);
            }
        }
        return rlt;
    }
};

int stringToInteger(string input) {
    return stoi(input);
